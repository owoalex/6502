/*

ZX v1.0.0
Copyright (c) Alex Baldwin 2020.

ZX is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License,
version 2 exclusively, as published by the Free Software Foundation.

ZX is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with ZX. If not, see:
https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt/

*/

#include <iostream>

//#include <gtk/gtk.h>
#include "json.hpp"
#include <stdlib.h>
#include <cstring>
#include <fstream>
#include <streambuf>
#include <iomanip>

#include <stdio.h>
#include <unistd.h>

#include <sys/stat.h> // stat
#include <errno.h>    // errno, ENOENT, EEXIST
#if defined(_WIN32)
#include <direct.h>   // _mkdir
#endif

using json = nlohmann::json;

bool isDirExist(const std::string& path)
{
#if defined(_WIN32)
    struct _stat info;
    if (_stat(path.c_str(), &info) != 0)
    {
        return false;
    }
    return (info.st_mode & _S_IFDIR) != 0;
#else 
    struct stat info;
    if (stat(path.c_str(), &info) != 0)
    {
        return false;
    }
    return (info.st_mode & S_IFDIR) != 0;
#endif
}

bool makePath(const std::string& path)
{
#if defined(_WIN32)
    int ret = _mkdir(path.c_str());
#else
    mode_t mode = 0755;
    int ret = mkdir(path.c_str(), mode);
#endif
    if (ret == 0)
        return true;

    switch (errno)
    {
    case ENOENT:
        // parent didn't exist, try to create it
        {
            int pos = path.find_last_of('/');
            if (pos == (int) std::string::npos)
#if defined(_WIN32)
                pos = path.find_last_of('\\');
            if (pos == (int) std::string::npos)
#endif
                return false;
            if (!makePath( path.substr(0, pos) ))
                return false;
        }
        // now, try to create again
#if defined(_WIN32)
        return 0 == _mkdir(path.c_str());
#else 
        return 0 == mkdir(path.c_str(), mode);
#endif

    case EEXIST:
        // done!
        return isDirExist(path);

    default:
        return false;
    }
}

std::string primaryRom = "";
std::string secondaryRom = "";
std::string fullRom = "";

uint8_t virtualMemoryMap[0x010000];

uint8_t virtualAccumulator = 0;
uint8_t virtualXRegister = 0;
uint8_t virtualYRegister = 0;
uint16_t virtualProgramCounter = 0;
uint8_t virtualStackPointer = 0;
uint8_t virtualStatus = 0;
bool halted = true;

uint16_t getShortFromAddress(int addr) {
    return ((uint16_t)virtualMemoryMap[addr]) + (((uint16_t)virtualMemoryMap[addr + 1]) * 256);
}

void setShortAtAddress(int addr, uint16_t value) {
    virtualMemoryMap[addr] = value % 256;
    virtualMemoryMap[addr + 1] = value / 256;
}

uint8_t popByteFromStack() {
    virtualStackPointer++;
    return virtualMemoryMap[0x0100 + virtualStackPointer];
}

uint16_t popShortFromStack() {
    return (((uint16_t) popByteFromStack()) * 256) + ((uint16_t) popByteFromStack());
}

void pushByteToStack(uint8_t value) {
    virtualMemoryMap[0x0100 + virtualStackPointer] = value;
    virtualStackPointer--;
}

void pushShortToStack(uint16_t value) {
    pushByteToStack(value % 256);
    pushByteToStack(value / 256);
}

void clearCarryFlag() {
    virtualStatus &= ~(1UL << 0); // Set bit to 0
}

void setCarryFlag() {
    virtualStatus |= 1UL << 0; // Set bit to 1
}

void clearZeroFlag() {
    virtualStatus &= ~(1UL << 1); // Set bit to 0
}

void setZeroFlag() {
    virtualStatus |= 1UL << 1; // Set bit to 1
}

void clearInterruptDisableStatus() {
    virtualStatus &= ~(1UL << 2); // Set bit to 0
}

void setInterruptDisableStatus() {
    virtualStatus |= 1UL << 2; // Set bit to 1
}

void clearDecimalMode() {
    virtualStatus &= ~(1UL << 3); // Set bit to 0
}

void setDecimalMode() {
    virtualStatus |= 1UL << 3; // Set bit to 1
}

void clearBreakFlag() {
    virtualStatus &= ~(1UL << 4); // Set bit to 0
}

void setBreakFlag() {
    virtualStatus |= 1UL << 4; // Set bit to 1
}

void clearOverflowFlag() {
    virtualStatus &= ~(1UL << 6); // Set bit to 0
}

void setOverflowFlag() {
    virtualStatus |= 1UL << 6; // Set bit to 1
}

void clearNegativeFlag() {
    virtualStatus &= ~(1UL << 7); // Set bit to 0
}

void setNegativeFlag() {
    virtualStatus |= 1UL << 7; // Set bit to 1
}

bool isCarryFlagSet() {
    return (((virtualStatus >> 0) & 1U) == 1)
}

bool isZeroFlagSet() {
    return (((virtualStatus >> 1) & 1U) == 1)
}

bool isInterruptDisableSet() {
    return (((virtualStatus >> 2) & 1U) == 1)
}

bool isDecimalModeSet() {
    return (((virtualStatus >> 3) & 1U) == 1)
}

bool isBreakFlagSet() {
    return (((virtualStatus >> 4) & 1U) == 1)
}

bool isOverflowFlagSet() {
    return (((virtualStatus >> 6) & 1U) == 1)
}

bool isNegativeFlagSet() {
    return (((virtualStatus >> 7) & 1U) == 1)
}

// virtualStatus |= 1UL << 4; set bit 4 to 1
// virtualStatus &= ~(1UL << 4); set bit 4 to 0
// virtualStatus ^= 1UL << 4; flip bit 4

void resetProcessor() {
    virtualProgramCounter = getShortFromAddress(0xfffc);
    printf("RESET program counter to to 0x%04x\n",virtualProgramCounter);
    halted = false;
    virtualStackPointer = 0xfd;
}

void printAddress(int s, int e) {
    for (int i = s; i <= e; i++) {
        printf("0x%04x", i * 16);
        std::cout << " ";
        for (int j = 0; j < 16; j++) {
            if ((j % 2) == 0) {
                std::cout << " ";
            }
            printf("%02x", virtualMemoryMap[(i*16) + j]);
        }
        std::cout << "\n";
    }
}

void printAddressAbs(int s, int e) {
    printAddress(s / 16, e / 16);
}

void stepVirtualProcessor() {
    uint8_t operandByte;
    uint16_t operandShort;
    
    uint8_t temporaryByte;
    uint16_t temporaryShort;
    
    uint8_t bitZeroTest = 1 << 0; // select bit 0
    uint8_t bitSevenTest = 1 << 7; // select bit 0
    
    //https://en.wikibooks.org/wiki/6502_Assembly#Instructions
    
    /*Instruction progress
     * 
     * ##100% DONE WITH FLAGS
     * Set and Clear
     * Miscellaneous
     * Stack
     * Subroutines and Jump
     * 
     * ##DONE
     * Load and Store
     * Transfer
     * Shift and Rotate
     * Branch
     * 
     * ##IN PROGRESS
     * Compare and Test Bit
     * 
     * ##NOT STARTED
     * Arithmetic
     * Increment and Decrement
     * Logic
     * 
     */
    
    switch (virtualMemoryMap[virtualProgramCounter]) {
        //FLAGS
        case (uint8_t)0x18:
            printf("CLC Clear Carry Flag");
            clearCarryFlag();
            virtualProgramCounter++;
            break;
        case (uint8_t)0x38:
            printf("SEC Set Carry Flag");
            setCarryFlag();
            virtualProgramCounter++;
            break;
        case (uint8_t)0xd8:
            printf("CLD Clear Decimal Mode");
            clearDecimalMode();
            virtualProgramCounter++;
            break;
        case (uint8_t)0xf8:
            printf("SED Set Decimal Mode");
            setDecimalMode();
            virtualProgramCounter++;
            break;
        case (uint8_t)0x58:
            printf("CLI Clear Interrupt Disable Status");
            clearInterruptDisableStatus();
            virtualProgramCounter++;
            break;
        case (uint8_t)0x78:
            printf("SEI Set Interrupt Disable Status");
            setInterruptDisableStatus();
            virtualProgramCounter++;
            break;
        case (uint8_t)0xb8:
            printf("CLV Clear Overflow Flag");
            clearOverflowFlag();
            virtualProgramCounter++;
            break;
        //COMPARE AND TEST BIT
        
        
        //TRANSFERS
        case (uint8_t)0xaa:
            printf("TAX");
            virtualXRegister = virtualAccumulator;
            virtualProgramCounter++;
            break;
        case (uint8_t)0x8a:
            printf("TXA");
            virtualAccumulator = virtualXRegister;
            virtualProgramCounter++;
            break;
        case (uint8_t)0xa8:
            printf("TAY");
            virtualYRegister = virtualAccumulator;
            virtualProgramCounter++;
            break;
        case (uint8_t)0x98:
            printf("TYA");
            virtualAccumulator = virtualYRegister;
            virtualProgramCounter++;
            break;
        case (uint8_t)0xba:
            printf("TSX");
            virtualXRegister = virtualStackPointer;
            virtualProgramCounter++;
            break;
        case (uint8_t)0x9a:
            printf("TXS");
            virtualStackPointer = virtualXRegister;
            virtualProgramCounter++;
            break;
        //STACK
        case (uint8_t)0x48:
            printf("PHA Push Accumulator on Stack");
            //virtualAccumulator = virtualXRegister;
            pushByteToStack(virtualAccumulator);
            printf("\nStack Status:\n");
            printAddressAbs(0x0100, 0x01ff);
            virtualProgramCounter++;
            break;
        case (uint8_t)0x08:
            printf("PHP Push Processor Status on Stack");
            //virtualAccumulator = virtualXRegister;
            pushByteToStack(virtualStatus);
            printf("\nStack Status:\n");
            printAddressAbs(0x0100, 0x01ff);
            virtualProgramCounter++;
            break;
        case (uint8_t)0x68:
            printf("PLA Pull Accumulator from Stack");
            //virtualAccumulator = virtualXRegister;
            virtualAccumulator = popByteFromStack();
            printf("\nStack Status:\n");
            printAddressAbs(0x0100, 0x01ff);
            virtualProgramCounter++;
            break;
        case (uint8_t)0x28:
            printf("PLP Pull Processor Status from Stack");
            //virtualAccumulator = virtualXRegister;
            virtualStatus = popByteFromStack();
            printf("\nStack Status:\n");
            printAddressAbs(0x0100, 0x01ff);
            virtualProgramCounter++;
            break;
        //JUMPS
        case (uint8_t)0x4c:
            virtualProgramCounter = getShortFromAddress(virtualProgramCounter + 1);
            printf("JMP Absolute to 0x%04x",virtualProgramCounter);
            break;
        case (uint8_t)0x6c:
            virtualProgramCounter = getShortFromAddress(getShortFromAddress(virtualProgramCounter + 1));
            printf("JMP Indirect to 0x%04x",virtualProgramCounter);
            break;
        case (uint8_t)0x20:
            printf("JSR Absolute to 0x%04x",getShortFromAddress(virtualProgramCounter + 1));
            
            pushShortToStack(virtualProgramCounter + 2);// push address of next instruction less one to stack
            printf("\nStack Status:\n");
            printAddressAbs(0x0100, 0x01ff);
            
            virtualProgramCounter = getShortFromAddress(virtualProgramCounter + 1);
            break;
        case (uint8_t)0x60:
            virtualProgramCounter = popShortFromStack();
            virtualProgramCounter++;
            printf("\nStack Status:\n");
            printAddressAbs(0x0100, 0x01ff);
            
            printf("RTS to 0x%04x",virtualProgramCounter);
            //virtualAccumulator = virtualXRegister;
            break;
        case (uint8_t)0x40:
            virtualStatus = popByteFromStack();
            virtualProgramCounter = popShortFromStack();
            virtualProgramCounter++;
            printf("\nStack Status:\n");
            printAddressAbs(0x0100, 0x01ff);
            
            printf("RTI to 0x%04x with status 0x%02x",virtualProgramCounter, virtualStatus);
            //virtualAccumulator = virtualXRegister;
            
            break;
        //BRANCH
        case (uint8_t)0x90:
            operandByte = getShortFromAddress(virtualProgramCounter + 1);
            printf("BCC Branch on Carry Clear to 0x%04x (displacement 0x%02x)",virtualProgramCounter + static_cast<uint8_t>(operandByte) + 2, static_cast<int8_t>(operandByte));
            if (!isCarryFlagSet()) {
                printf(" - Did Jump");
                virtualProgramCounter = virtualProgramCounter + static_cast<int8_t>(operandByte) + 2;
            } else {
                printf(" - Did Not Jump");
                virtualProgramCounter += 2;
            }
            break;
        case (uint8_t)0xb0:
            operandByte = getShortFromAddress(virtualProgramCounter + 1);
            printf("BCS Branch on Carry Set to 0x%04x (displacement 0x%02x)",virtualProgramCounter + static_cast<uint8_t>(operandByte) + 2, static_cast<int8_t>(operandByte));
            if (isCarryFlagSet()) {
                printf(" - Did Jump");
                virtualProgramCounter = virtualProgramCounter + static_cast<int8_t>(operandByte) + 2;
            } else {
                printf(" - Did Not Jump");
                virtualProgramCounter += 2;
            }
            break;
            
        case (uint8_t)0xd0:
            operandByte = getShortFromAddress(virtualProgramCounter + 1);
            printf("BNE Branch on Result not Zero to 0x%04x (displacement 0x%02x)",virtualProgramCounter + static_cast<uint8_t>(operandByte) + 2, static_cast<int8_t>(operandByte));
            if (!isZeroFlagSet()) {
                printf(" - Did Jump");
                virtualProgramCounter = virtualProgramCounter + static_cast<int8_t>(operandByte) + 2;
            } else {
                printf(" - Did Not Jump");
                virtualProgramCounter += 2;
            }
            break;
        case (uint8_t)0xf0:
            operandByte = getShortFromAddress(virtualProgramCounter + 1);
            printf("BEQ Branch on Result Zero to 0x%04x (displacement 0x%02x)",virtualProgramCounter + static_cast<uint8_t>(operandByte) + 2, static_cast<int8_t>(operandByte));
            if (isZeroFlagSet()) {
                printf(" - Did Jump");
                virtualProgramCounter = virtualProgramCounter + static_cast<int8_t>(operandByte) + 2;
            } else {
                printf(" - Did Not Jump");
                virtualProgramCounter += 2;
            }
            break;
            
        case (uint8_t)0x10:
            operandByte = getShortFromAddress(virtualProgramCounter + 1);
            printf("BPL Branch on plus to 0x%04x (displacement 0x%02x)",virtualProgramCounter + static_cast<uint8_t>(operandByte) + 2, static_cast<int8_t>(operandByte));
            if (!isNegativeFlagSet()) {
                printf(" - Did Jump");
                virtualProgramCounter = virtualProgramCounter + static_cast<int8_t>(operandByte) + 2;
            } else {
                printf(" - Did Not Jump");
                virtualProgramCounter += 2;
            }
            break;
        case (uint8_t)0x30:
            operandByte = getShortFromAddress(virtualProgramCounter + 1);
            printf("BMI Branch on minus to 0x%04x (displacement 0x%02x)",virtualProgramCounter + static_cast<uint8_t>(operandByte) + 2, static_cast<int8_t>(operandByte));
            if (isNegativeFlagSet()) {
                printf(" - Did Jump");
                virtualProgramCounter = virtualProgramCounter + static_cast<int8_t>(operandByte) + 2;
            } else {
                printf(" - Did Not Jump");
                virtualProgramCounter += 2;
            }
            break;
            
        case (uint8_t)0x50:
            operandByte = getShortFromAddress(virtualProgramCounter + 1);
            printf("BVC Branch on Overflow Clear to 0x%04x (displacement 0x%02x)",virtualProgramCounter + static_cast<uint8_t>(operandByte) + 2, static_cast<int8_t>(operandByte));
            if (!isOverflowFlagSet()) {
                printf(" - Did Jump");
                virtualProgramCounter = virtualProgramCounter + static_cast<int8_t>(operandByte) + 2;
            } else {
                printf(" - Did Not Jump");
                virtualProgramCounter += 2;
            }
            break;
        case (uint8_t)0x70:
            operandByte = getShortFromAddress(virtualProgramCounter + 1);
            printf("BVS Branch on Overflow Set to 0x%04x (displacement 0x%02x)",virtualProgramCounter + static_cast<uint8_t>(operandByte) + 2, static_cast<int8_t>(operandByte));
            if (isOverflowFlagSet()) {
                printf(" - Did Jump");
                virtualProgramCounter = virtualProgramCounter + static_cast<int8_t>(operandByte) + 2;
            } else {
                printf(" - Did Not Jump");
                virtualProgramCounter += 2;
            }
            break;
        //LOAD
            //LOAD ACC
        case (uint8_t)0xad:
            operandShort = getShortFromAddress(virtualProgramCounter + 1);
            temporaryByte = virtualMemoryMap[operandShort];
            printf("LDA with data at 0x%04x (value 0x%02x)",operandShort,temporaryByte);
            virtualAccumulator = temporaryByte;
            virtualProgramCounter += 3;
            break;
        case (uint8_t)0xbd:
            operandShort = getShortFromAddress(virtualProgramCounter + 1);
            temporaryByte = virtualMemoryMap[operandShort + virtualXRegister];
            printf("LDA with data at 0x%04x (value 0x%02x)",operandShort + virtualXRegister,temporaryByte);
            virtualAccumulator = temporaryByte;
            virtualProgramCounter += 3;
            break;
        case (uint8_t)0xb9:
            operandShort = getShortFromAddress(virtualProgramCounter + 1);
            temporaryByte = virtualMemoryMap[operandShort + virtualYRegister];
            printf("LDA with data at 0x%04x (value 0x%02x)",operandShort + virtualYRegister,temporaryByte);
            virtualAccumulator = temporaryByte;
            virtualProgramCounter += 3;
            break;
            
        case (uint8_t)0xa9:
            operandByte = virtualMemoryMap[virtualProgramCounter + 1];
            printf("LDA with 0x%02x literal",operandByte);
            virtualAccumulator = operandByte;
            virtualProgramCounter += 2;
            break;
            
        case (uint8_t)0xa5:
            operandByte = virtualMemoryMap[virtualProgramCounter + 1];
            temporaryByte = virtualMemoryMap[operandByte];
            printf("LDA with data at 0x%02x (value 0x%02x)",operandByte,temporaryByte);
            virtualAccumulator = temporaryByte;
            virtualProgramCounter += 2;
            break;
        case (uint8_t)0xa1:
            operandByte = virtualMemoryMap[virtualProgramCounter + 1];
            temporaryShort = getShortFromAddress(operandByte + virtualXRegister);
            temporaryByte = virtualMemoryMap[temporaryShort];
            printf("LDA with data at 0x%02x (value 0x%02x)",temporaryShort,temporaryByte);
            virtualAccumulator = temporaryByte;
            virtualProgramCounter += 2;
            break;
        case (uint8_t)0xb5:
            operandByte = virtualMemoryMap[virtualProgramCounter + 1];
            temporaryByte = virtualMemoryMap[operandByte + virtualXRegister];
            printf("LDA with data at 0x%02x (value 0x%02x)",operandByte,temporaryByte);
            virtualAccumulator = temporaryByte;
            virtualProgramCounter += 2;
            break;
        case (uint8_t)0xb1:
            operandByte = virtualMemoryMap[virtualProgramCounter + 1];
            temporaryShort = getShortFromAddress(operandByte) + virtualYRegister;
            temporaryByte = virtualMemoryMap[temporaryShort];
            printf("LDA with data at 0x%02x (value 0x%02x)",temporaryShort,temporaryByte);
            virtualAccumulator = temporaryByte;
            virtualProgramCounter += 2;
            break;
            //LOAD X
        case (uint8_t)0xae:
            operandShort = getShortFromAddress(virtualProgramCounter + 1);
            temporaryByte = virtualMemoryMap[operandShort];
            printf("LDX with data at 0x%04x (value 0x%02x)",operandShort,temporaryByte);
            virtualXRegister = temporaryByte;
            virtualProgramCounter += 3;
            break;
        case (uint8_t)0xbe:
            operandShort = getShortFromAddress(virtualProgramCounter + 1);
            temporaryByte = virtualMemoryMap[operandShort + virtualYRegister];
            printf("LDX with data at 0x%04x (value 0x%02x)",operandShort + virtualYRegister,temporaryByte);
            virtualXRegister = temporaryByte;
            virtualProgramCounter += 3;
            break;
            
        case (uint8_t)0xa2:
            operandByte = virtualMemoryMap[virtualProgramCounter + 1];
            printf("LDX with 0x%02x literal",operandByte);
            virtualXRegister = operandByte;
            virtualProgramCounter += 2;
            break;
            
        case (uint8_t)0xa6:
            operandByte = virtualMemoryMap[virtualProgramCounter + 1];
            temporaryByte = virtualMemoryMap[operandByte];
            printf("LDX with data at 0x%02x (value 0x%02x)",operandByte,temporaryByte);
            virtualXRegister = temporaryByte;
            virtualProgramCounter += 2;
            break;
        case (uint8_t)0xb6:
            operandByte = virtualMemoryMap[virtualProgramCounter + 1];
            temporaryByte = virtualMemoryMap[operandByte + virtualYRegister];
            printf("LDX with data at 0x%02x (value 0x%02x)",operandByte,temporaryByte);
            virtualXRegister = temporaryByte;
            virtualProgramCounter += 2;
            break;
            //LOAD Y
        case (uint8_t)0xac:
            operandShort = getShortFromAddress(virtualProgramCounter + 1);
            temporaryByte = virtualMemoryMap[operandShort];
            printf("LDY with data at 0x%04x (value 0x%02x)",operandShort,temporaryByte);
            virtualYRegister = temporaryByte;
            virtualProgramCounter += 3;
            break;
        case (uint8_t)0xbc:
            operandShort = getShortFromAddress(virtualProgramCounter + 1);
            temporaryByte = virtualMemoryMap[operandShort + virtualXRegister];
            printf("LDY with data at 0x%04x (value 0x%02x)",operandShort + virtualXRegister,temporaryByte);
            virtualYRegister = temporaryByte;
            virtualProgramCounter += 3;
            break;
            
        case (uint8_t)0xa0:
            operandByte = virtualMemoryMap[virtualProgramCounter + 1];
            printf("LDY with 0x%02x literal",operandByte);
            virtualYRegister = operandByte;
            virtualProgramCounter += 2;
            break;
            
        case (uint8_t)0xa4:
            operandByte = virtualMemoryMap[virtualProgramCounter + 1];
            temporaryByte = virtualMemoryMap[operandByte];
            printf("LDY with data at 0x%02x (value 0x%02x)",operandByte,temporaryByte);
            virtualYRegister = temporaryByte;
            virtualProgramCounter += 2;
            break;
        case (uint8_t)0xb4:
            operandByte = virtualMemoryMap[virtualProgramCounter + 1];
            temporaryByte = virtualMemoryMap[operandByte + virtualXRegister];
            printf("LDY with data at 0x%02x (value 0x%02x)",operandByte,temporaryByte);
            virtualYRegister = temporaryByte;
            virtualProgramCounter += 2;
            break;
        //STORE
            //STORE ACC
        case (uint8_t)0x8d:
            operandShort = getShortFromAddress(virtualProgramCounter + 1);
            printf("STA data at 0x%04x (value 0x%02x)",operandShort,virtualAccumulator);
            virtualMemoryMap[operandShort] = virtualAccumulator;
            virtualProgramCounter += 3;
            break;
        case (uint8_t)0x9d:
            operandShort = getShortFromAddress(virtualProgramCounter + 1);
            printf("STA data at 0x%04x (value 0x%02x)",operandShort + virtualXRegister,virtualAccumulator);
            virtualMemoryMap[operandShort + virtualXRegister] = virtualAccumulator;
            virtualProgramCounter += 3;
            break;
        case (uint8_t)0x99:
            operandShort = getShortFromAddress(virtualProgramCounter + 1);
            printf("STA data at 0x%04x (value 0x%02x)",operandShort + virtualYRegister,virtualAccumulator);
            virtualMemoryMap[operandShort + virtualYRegister] = virtualAccumulator;
            virtualProgramCounter += 3;
            break;
            
        case (uint8_t)0x85:
            operandByte = virtualMemoryMap[virtualProgramCounter + 1];
            printf("STA data at 0x%02x (value 0x%02x)",operandByte,virtualAccumulator);
            virtualMemoryMap[operandByte] = virtualAccumulator;
            virtualProgramCounter += 2;
            break;
        case (uint8_t)0x81:
            operandByte = virtualMemoryMap[virtualProgramCounter + 1];
            temporaryShort = getShortFromAddress(operandByte + virtualXRegister);
            printf("STA data at 0x%02x (value 0x%02x)",temporaryShort,virtualAccumulator);
            virtualMemoryMap[temporaryShort] = virtualAccumulator;
            virtualProgramCounter += 2;
            break;
        case (uint8_t)0x95:
            operandByte = virtualMemoryMap[virtualProgramCounter + 1];
            printf("STA data at 0x%02x (value 0x%02x)",operandByte + virtualXRegister,virtualAccumulator);
            virtualMemoryMap[operandByte + virtualXRegister] = virtualAccumulator;
            virtualProgramCounter += 2;
            break;
        case (uint8_t)0x91:
            operandByte = virtualMemoryMap[virtualProgramCounter + 1];
            temporaryShort = getShortFromAddress(operandByte) + virtualYRegister;
            printf("STA data at 0x%02x (value 0x%02x)",temporaryShort,virtualAccumulator);
            virtualMemoryMap[temporaryShort] = virtualAccumulator;
            virtualProgramCounter += 2;
            break;
            //STORE X
        case (uint8_t)0x8e:
            operandShort = getShortFromAddress(virtualProgramCounter + 1);
            printf("STX data at 0x%04x (value 0x%02x)",operandShort,virtualXRegister);
            virtualMemoryMap[operandShort] = virtualXRegister;
            virtualProgramCounter += 3;
            break;
        case (uint8_t)0x86:
            operandByte = virtualMemoryMap[virtualProgramCounter + 1];
            printf("STX data at 0x%02x (value 0x%02x)",operandByte,virtualXRegister);
            virtualMemoryMap[operandByte] = virtualXRegister;
            virtualProgramCounter += 2;
            break;
        case (uint8_t)0x96:
            operandByte = virtualMemoryMap[virtualProgramCounter + 1];
            printf("STX data at 0x%02x (value 0x%02x)",operandByte + virtualYRegister,virtualXRegister);
            virtualMemoryMap[operandByte + virtualYRegister] = virtualXRegister;
            virtualProgramCounter += 2;
            break;
            //STORE Y
        case (uint8_t)0x8c:
            operandShort = getShortFromAddress(virtualProgramCounter + 1);
            printf("STY data at 0x%04x (value 0x%02x)",operandShort,virtualYRegister);
            virtualMemoryMap[operandShort] = virtualYRegister;
            virtualProgramCounter += 3;
            break;
        case (uint8_t)0x84:
            operandByte = virtualMemoryMap[virtualProgramCounter + 1];
            printf("STY data at 0x%02x (value 0x%02x)",operandByte,virtualYRegister);
            virtualMemoryMap[operandByte] = virtualYRegister;
            virtualProgramCounter += 2;
            break;
        case (uint8_t)0x94:
            operandByte = virtualMemoryMap[virtualProgramCounter + 1];
            printf("STY data at 0x%02x (value 0x%02x)",operandByte + virtualXRegister,virtualYRegister);
            virtualMemoryMap[operandByte + virtualXRegister] = virtualYRegister;
            virtualProgramCounter += 2;
            break;
        //SHIFT AND ROTATE
            //SHIFT LEFT
        case (uint8_t)0x0e:
            printf("ASL Arithmetic Shift Left");
            operandShort = getShortFromAddress(virtualProgramCounter + 1);
            if (virtualMemoryMap[operandShort] & bitSevenTest) {
                //SET CARRY HIGH (1)
                virtualStatus |= 1UL << 0; // Set bit to 1
            } else {
                //SET CARRY LOW (0)
                virtualStatus &= ~(1UL << 0); // Set bit to 0
            }
            virtualMemoryMap[operandShort] = (virtualMemoryMap[operandShort] << 1);
            virtualProgramCounter += 3;
            break;
        case (uint8_t)0x1e:
            printf("ASL Arithmetic Shift Left");
            operandShort = getShortFromAddress(virtualProgramCounter + 1) + virtualXRegister;
            if (virtualMemoryMap[operandShort] & bitSevenTest) {
                //SET CARRY HIGH (1)
                virtualStatus |= 1UL << 0; // Set bit to 1
            } else {
                //SET CARRY LOW (0)
                virtualStatus &= ~(1UL << 0); // Set bit to 0
            }
            virtualMemoryMap[operandShort] = (virtualMemoryMap[operandShort] << 1);
            virtualProgramCounter += 3;
            break;
        case (uint8_t)0x0a:
            printf("ASL Arithmetic Shift Left on Accumulator");
            if (virtualAccumulator & bitSevenTest) {
                //SET CARRY HIGH (1)
                virtualStatus |= 1UL << 0; // Set bit to 1
            } else {
                //SET CARRY LOW (0)
                virtualStatus &= ~(1UL << 0); // Set bit to 0
            }
            virtualAccumulator = (virtualAccumulator << 1);
            virtualProgramCounter++;
            break;
        case (uint8_t)0x06:
            printf("ASL Arithmetic Shift Left");
            operandByte = virtualMemoryMap[virtualProgramCounter + 1];
            if (virtualMemoryMap[operandByte] & bitSevenTest) {
                //SET CARRY HIGH (1)
                virtualStatus |= 1UL << 0; // Set bit to 1
            } else {
                //SET CARRY LOW (0)
                virtualStatus &= ~(1UL << 0); // Set bit to 0
            }
            virtualMemoryMap[operandByte] = (virtualMemoryMap[operandByte] << 1);
            virtualProgramCounter += 3;
            break;
        case (uint8_t)0x16:
            printf("ASL Arithmetic Shift Left");
            operandByte = virtualMemoryMap[virtualProgramCounter + 1] + virtualXRegister;
            if (virtualMemoryMap[operandByte] & bitSevenTest) {
                //SET CARRY HIGH (1)
                virtualStatus |= 1UL << 0; // Set bit to 1
            } else {
                //SET CARRY LOW (0)
                virtualStatus &= ~(1UL << 0); // Set bit to 0
            }
            virtualMemoryMap[operandByte] = (virtualMemoryMap[operandByte] << 1);
            virtualProgramCounter += 3;
            break;
            //SHIFT RIGHT
        case (uint8_t)0x4e:
            printf("LSR Logical Shift Right");
            operandShort = getShortFromAddress(virtualProgramCounter + 1);
            if (virtualMemoryMap[operandShort] & bitZeroTest) {
                //SET CARRY HIGH (1)
                virtualStatus |= 1UL << 0; // Set bit to 1
            } else {
                //SET CARRY LOW (0)
                virtualStatus &= ~(1UL << 0); // Set bit to 0
            }
            virtualMemoryMap[operandShort] = (virtualMemoryMap[operandShort] >> 1);
            virtualProgramCounter += 3;
            break;
        case (uint8_t)0x5e:
            printf("LSR Logical Shift Right");
            operandShort = getShortFromAddress(virtualProgramCounter + 1) + virtualXRegister;
            if (virtualMemoryMap[operandShort] & bitZeroTest) {
                //SET CARRY HIGH (1)
                virtualStatus |= 1UL << 0; // Set bit to 1
            } else {
                //SET CARRY LOW (0)
                virtualStatus &= ~(1UL << 0); // Set bit to 0
            }
            virtualMemoryMap[operandShort] = (virtualMemoryMap[operandShort] >> 1);
            virtualProgramCounter += 3;
            break;
        case (uint8_t)0x4a:
            printf("LSR Logical Shift Right on Accumulator");
            if (virtualAccumulator & bitZeroTest) {
                //SET CARRY HIGH (1)
                virtualStatus |= 1UL << 0; // Set bit to 1
            } else {
                //SET CARRY LOW (0)
                virtualStatus &= ~(1UL << 0); // Set bit to 0
            }
            virtualAccumulator = (virtualAccumulator >> 1);
            virtualProgramCounter++;
            break;
        case (uint8_t)0x46:
            printf("LSR Logical Shift Right");
            operandByte = virtualMemoryMap[virtualProgramCounter + 1];
            if (virtualMemoryMap[operandByte] & bitZeroTest) {
                //SET CARRY HIGH (1)
                virtualStatus |= 1UL << 0; // Set bit to 1
            } else {
                //SET CARRY LOW (0)
                virtualStatus &= ~(1UL << 0); // Set bit to 0
            }
            virtualMemoryMap[operandByte] = (virtualMemoryMap[operandByte] >> 1);
            virtualProgramCounter += 3;
            break;
        case (uint8_t)0x56:
            printf("LSR Logical Shift Right");
            operandByte = virtualMemoryMap[virtualProgramCounter + 1] + virtualXRegister;
            if (virtualMemoryMap[operandByte] & bitZeroTest) {
                //SET CARRY HIGH (1)
                virtualStatus |= 1UL << 0; // Set bit to 1
            } else {
                //SET CARRY LOW (0)
                virtualStatus &= ~(1UL << 0); // Set bit to 0
            }
            virtualMemoryMap[operandByte] = (virtualMemoryMap[operandByte] >> 1);
            virtualProgramCounter += 3;
            break;
            //ROTATE LEFT
        case (uint8_t)0x2e:
            printf("ROL Rotate Left One Bit");
            operandShort = getShortFromAddress(virtualProgramCounter + 1);
            if (virtualMemoryMap[operandShort] & bitSevenTest) {
                //SET CARRY HIGH (1)
                virtualMemoryMap[operandShort] = (virtualMemoryMap[operandShort] << 1);
                virtualMemoryMap[operandShort] |= 1UL << 0; // Set bit to 1
                virtualStatus |= 1UL << 0; // Set bit to 1
            } else {
                //SET CARRY LOW (0)
                virtualMemoryMap[operandShort] = (virtualMemoryMap[operandShort] << 1);
                virtualMemoryMap[operandShort] &= ~(1UL << 0); // Set bit to 0
                virtualStatus &= ~(1UL << 0); // Set bit to 0
            }
            virtualProgramCounter += 3;
            break;
        case (uint8_t)0x3e:
            printf("ROL Rotate Left One Bit");
            operandShort = getShortFromAddress(virtualProgramCounter + 1) + virtualXRegister;
            if (virtualMemoryMap[operandShort] & bitSevenTest) {
                //SET CARRY HIGH (1)
                virtualMemoryMap[operandShort] = (virtualMemoryMap[operandShort] << 1);
                virtualMemoryMap[operandShort] |= 1UL << 0; // Set bit to 1
                 virtualStatus |= 1UL << 0; // Set bit to 1
            } else {
                //SET CARRY LOW (0)
                virtualMemoryMap[operandShort] = (virtualMemoryMap[operandShort] << 1);
                virtualMemoryMap[operandShort] &= ~(1UL << 0); // Set bit to 0
                virtualStatus &= ~(1UL << 0); // Set bit to 0
            }
            virtualProgramCounter += 3;
            break;
        case (uint8_t)0x2a:
            printf("ROL Rotate Left One Bit on Accumulator");
            if (virtualAccumulator & bitSevenTest) {
                //SET CARRY HIGH (1)
                virtualAccumulator = (virtualAccumulator << 1);
                virtualAccumulator |= 1UL << 0; // Set bit to 1
                virtualStatus |= 1UL << 0; // Set bit to 1
            } else {
                //SET CARRY LOW (0)
                virtualAccumulator = (virtualAccumulator << 1);
                virtualAccumulator &= ~(1UL << 0); // Set bit to 0
                virtualStatus &= ~(1UL << 0); // Set bit to 0
            }
            virtualProgramCounter++;
            break;
        case (uint8_t)0x26:
            printf("ROL Rotate Left One Bit");
            operandByte = virtualMemoryMap[virtualProgramCounter + 1];
            if (virtualMemoryMap[operandByte] & bitSevenTest) {
                //SET CARRY HIGH (1)
                virtualMemoryMap[operandByte] = (virtualMemoryMap[operandByte] << 1);
                virtualMemoryMap[operandByte] |= 1UL << 0; // Set bit to 1
                virtualStatus |= 1UL << 0; // Set bit to 1
            } else {
                //SET CARRY LOW (0)
                virtualMemoryMap[operandByte] = (virtualMemoryMap[operandByte] << 1);
                virtualMemoryMap[operandByte] &= ~(1UL << 0); // Set bit to 0
                virtualStatus &= ~(1UL << 0); // Set bit to 0
            }
            virtualProgramCounter += 3;
            break;
        case (uint8_t)0x36:
            printf("ROL Rotate Left One Bit");
            operandByte = virtualMemoryMap[virtualProgramCounter + 1] + virtualXRegister;
            if (virtualMemoryMap[operandByte] & bitSevenTest) {
                //SET CARRY HIGH (1)
                virtualMemoryMap[operandByte] = (virtualMemoryMap[operandByte] << 1);
                virtualMemoryMap[operandByte] |= 1UL << 0; // Set bit to 1
                virtualStatus |= 1UL << 0; // Set bit to 1
            } else {
                //SET CARRY LOW (0)
                virtualMemoryMap[operandByte] = (virtualMemoryMap[operandByte] << 1);
                virtualMemoryMap[operandByte] &= ~(1UL << 0); // Set bit to 0
                virtualStatus &= ~(1UL << 0); // Set bit to 0
            }
            virtualProgramCounter += 3;
            break;
            //ROTATE RIGHT
        case (uint8_t)0x6e:
            printf("ROR Rotate Right One Bit");
            operandShort = getShortFromAddress(virtualProgramCounter + 1);
            if (virtualMemoryMap[operandShort] & bitZeroTest) {
                //SET CARRY HIGH (1)
                virtualMemoryMap[operandShort] = (virtualMemoryMap[operandShort] >> 1);
                virtualMemoryMap[operandShort] |= 1UL << 7; // Set bit to 1
                virtualStatus |= 1UL << 0; // Set bit to 1
            } else {
                //SET CARRY LOW (0)
                virtualMemoryMap[operandShort] = (virtualMemoryMap[operandShort] >> 1);
                virtualMemoryMap[operandShort] &= ~(1UL << 7); // Set bit to 0
                virtualStatus &= ~(1UL << 0); // Set bit to 0
            }
            virtualProgramCounter += 3;
            break;
        case (uint8_t)0x7e:
            printf("ROR Rotate Right One Bit");
            operandShort = getShortFromAddress(virtualProgramCounter + 1) + virtualXRegister;
            if (virtualMemoryMap[operandShort] & bitZeroTest) {
                //SET CARRY HIGH (1)
                virtualMemoryMap[operandShort] = (virtualMemoryMap[operandShort] >> 1);
                virtualMemoryMap[operandShort] |= 1UL << 7; // Set bit to 1
                virtualStatus |= 1UL << 0; // Set bit to 1
            } else {
                //SET CARRY LOW (0)
                virtualMemoryMap[operandShort] = (virtualMemoryMap[operandShort] >> 1);
                virtualMemoryMap[operandShort] &= ~(1UL << 7); // Set bit to 0
                virtualStatus &= ~(1UL << 0); // Set bit to 0
            }
            virtualProgramCounter += 3;
            break;
        case (uint8_t)0x6a:
            printf("ROR Rotate Right One Bit on Accumulator");
            if (virtualAccumulator & bitZeroTest) {
                //SET CARRY HIGH (1)
                virtualAccumulator = (virtualAccumulator >> 1);
                virtualAccumulator |= 1UL << 7; // Set bit to 1
                virtualStatus |= 1UL << 0; // Set bit to 1
            } else {
                //SET CARRY LOW (0)
                virtualAccumulator = (virtualAccumulator >> 1);
                virtualAccumulator &= ~(1UL << 7); // Set bit to 0
                virtualStatus &= ~(1UL << 0); // Set bit to 0
            }
            virtualProgramCounter++;
            break;
        case (uint8_t)0x66:
            printf("ROR Rotate Right One Bit");
            operandByte = virtualMemoryMap[virtualProgramCounter + 1];
            if (virtualMemoryMap[operandByte] & bitZeroTest) {
                //SET CARRY HIGH (1)
                virtualMemoryMap[operandByte] = (virtualMemoryMap[operandByte] >> 1);
                virtualMemoryMap[operandByte] |= 1UL << 7; // Set bit to 1
                virtualStatus |= 1UL << 0; // Set bit to 1
            } else {
                //SET CARRY LOW (0)
                virtualMemoryMap[operandByte] = (virtualMemoryMap[operandByte] >> 1);
                virtualMemoryMap[operandByte] &= ~(1UL << 7); // Set bit to 0
                virtualStatus &= ~(1UL << 0); // Set bit to 0
            }
            virtualProgramCounter += 3;
            break;
        case (uint8_t)0x76:
            printf("ROR Rotate Right One Bit");
            operandByte = virtualMemoryMap[virtualProgramCounter + 1] + virtualXRegister;
            if (virtualMemoryMap[operandByte] & bitZeroTest) {
                //SET CARRY HIGH (1)
                virtualMemoryMap[operandByte] = (virtualMemoryMap[operandByte] >> 1);
                virtualMemoryMap[operandByte] |= 1UL << 7; // Set bit to 1
                virtualStatus |= 1UL << 0; // Set bit to 1
            } else {
                //SET CARRY LOW (0)
                virtualMemoryMap[operandByte] = (virtualMemoryMap[operandByte] >> 1);
                virtualMemoryMap[operandByte] &= ~(1UL << 7); // Set bit to 0
                virtualStatus &= ~(1UL << 0); // Set bit to 0
            }
            virtualProgramCounter += 3;
            break;
        //CONTROL
        case (uint8_t)0xea:
            printf("NOP No operation");
            virtualProgramCounter++;
            break;
        case (uint8_t)0x00:
            printf("BRK Program End");
            //BRK causes a non-maskable interrupt and increments the program counter by one. Therefore an RTI will go to the address of the BRK +2 so that BRK may be used to replace a two-byte instruction for debugging and the subsequent RTI will be correct. 
            virtualStatus |= 1UL << 4; // Set bit to 1
            virtualStatus |= 1UL << 2; // Set bit to 1
            halted = true;
            virtualProgramCounter++;
            break;
        default:
            printf("Unknown Instruction 0x%02x", virtualMemoryMap[virtualProgramCounter]);
            virtualProgramCounter++;
    }
    printf("\n");
}

int main(int argc, char** argv) {
    std::cout << "BBC Micro Emulator v1.0.0\nCopyright (c) Alex Baldwin 2020.\n\n";
    
    bool printHelp = false;

	for (int i = 1; i < argc; ++i) {
        std::string arg = argv[i];
        if (arg == "-p") {
            i++;
            std::string arg2 = argv[i];
            primaryRom = arg2;
            continue;
        }
        if (arg == "-s") {
            i++;
            std::string arg2 = argv[i];
            secondaryRom = arg2;
            continue;
        }
        if (arg == "-f") {
            i++;
            std::string arg2 = argv[i];
            fullRom = arg2;
            continue;
        }
        if (arg == "-h" || arg == "--help") {
            printHelp = true;
            break;
        }
        //cartridgeRom = arg;
    }
    
    if (printHelp) {
        std::cout << "Select a Primary (Machine Operating System) ROM\n";
        std::cout << "  -p <romFile>\n";
        std::cout << "Select a Secondary (BBC BASIC) ROM\n";
        std::cout << "  -s <romFile>\n";
    } else {
        if (fullRom.length() == 0) {
            std::cout << "Primary ROM       : " << primaryRom << "\n";
            std::cout << "Secondary ROM     : " << secondaryRom << "\n";
            
            FILE *fileptr;
            uint8_t *buffer;
            int filelen;

            fileptr = fopen(primaryRom.c_str(), "rb");  // Open the file in binary mode
            fseek(fileptr, 0, SEEK_END);        // Jump to the end of the file
            filelen = ftell(fileptr);           // Get the current byte offset in the file
            rewind(fileptr);                    // Jump back to the beginning of the file

            buffer = (uint8_t *)malloc(filelen * sizeof(char)); // Enough memory for the file
            fread(buffer, filelen, 1, fileptr); // Read in the entire file
            fclose(fileptr); // Close the file
            
            for (int i = 0; i < (1024 * 16); i++) {
                virtualMemoryMap[i + 0xC000] = buffer[i]; // CONFIRMED CORRECT
            }

            fileptr = fopen(secondaryRom.c_str(), "rb");  // Open the file in binary mode
            fseek(fileptr, 0, SEEK_END);        // Jump to the end of the file
            filelen = ftell(fileptr);           // Get the current byte offset in the file
            rewind(fileptr);                    // Jump back to the beginning of the file

            buffer = (uint8_t *)malloc(filelen * sizeof(char)); // Enough memory for the file
            fread(buffer, filelen, 1, fileptr); // Read in the entire file
            fclose(fileptr); // Close the file
            
            for (int i = 0; i < (1024 * 16); i++) {
                virtualMemoryMap[i + 0x8000] = buffer[i];
            }
        } else {
            std::cout << "Full ROM          : " << fullRom << "\n";
            
            FILE *fileptr;
            uint8_t *buffer;
            int filelen;

            fileptr = fopen(fullRom.c_str(), "rb");  // Open the file in binary mode
            fseek(fileptr, 0, SEEK_END);        // Jump to the end of the file
            filelen = ftell(fileptr);           // Get the current byte offset in the file
            rewind(fileptr);                    // Jump back to the beginning of the file

            buffer = (uint8_t *)malloc(filelen * sizeof(char)); // Enough memory for the file
            fread(buffer, filelen, 1, fileptr); // Read in the entire file
            fclose(fileptr); // Close the file
            
            for (int i = 0; i < 0x8000; i++) {
                virtualMemoryMap[i + 0x8000] = buffer[i];
            }
        }
        
        std::cout << "\n";
        
        resetProcessor();
        
        std::cout << "\n";
        std::cout << "Press enter to step processor";
        std::cout << "\n";
        
        while (true) {
            if (halted) {
                break;
            } else {
                std::cout << "\nProgram Counter   : ";
                printf("0x%04x", virtualProgramCounter);
                std::cout << "\nAccumulator       : ";
                printf("0x%02x", virtualAccumulator);
                std::cout << "\nX Register        : ";
                printf("0x%02x", virtualXRegister);
                std::cout << "\nY Register        : ";
                printf("0x%02x", virtualYRegister);
                std::cout << "\nStack Pointer     : ";
                printf("0x%02x", virtualStackPointer);
                std::cout << "\nMemory Map        : " << "\n";
                printAddress(virtualProgramCounter/16,(virtualProgramCounter/16) + 2);
                getchar();
                stepVirtualProcessor();
            }
        }
        std::cout << "Halted at         : ";
        printf("0x%04x", virtualProgramCounter);
        std::cout << "\n";
        std::cout << "Memory Map        : " << "\n";
        printAddress(virtualProgramCounter/16,(virtualProgramCounter/16) + 2);
    }

    //makePath(qemuConfigFolder);
    
    //std::ifstream t(vmList);
    //std::string options;

    //t.seekg(0, std::ios::end);
    //options.reserve(t.tellg());
    //t.seekg(0, std::ios::beg);

    //options.assign((std::istreambuf_iterator<char>(t)),
    //                std::istreambuf_iterator<char>());
    //vmOptions = json::parse(options);
    
    //for (auto& element : vmOptions) {
        //std::cout << element << '\n';
    //    VMObj vmobj(element);
    //    vms.push_back(vmobj);
    //}
    
    

    return 0;
}
